{
    "version": "https://jsonfeed.org/version/1",
    "title": "Robin Pellegrims",
    "home_page_url": "https://www.pellegrims.dev",
    "feed_url": "https://www.pellegrims.dev/rss/feed.json",
    "description": "Professional software developer, front-end technical lead and freelance web developer.",
    "icon": "https://www.pellegrims.devhttps://www.pellegrims.dev/avataaar.png",
    "author": {
        "name": "Robin Pellegrims",
        "url": "https://twitter.com/robinpel"
    },
    "items": [
        {
            "id": "https://www.pellegrims.dev/blog/e2e-contact-form-cypress/",
            "content_html": "<h2>Introduction</h2>\n<p>Many websites have a dedicated contact form that allows users to send a message to the website owner.\nUsing <a href=\"https://www.cypress.io/\" target=\"_blank\" rel=\"noreferrer\">Cypress</a>, we can easily write automated tests to prevent regressions to these types of\nforms.</p>\n<h2>Use case</h2>\n<p>For this article, we'll use a contact form containing three fields:</p>\n<ul>\n<li>Name</li>\n<li>E-Mail</li>\n<li>Message</li>\n</ul>\n<p><img src=\"https://www.pellegrims.dev/assets/blog/e2e-contact-form-cypress/form.png\" alt=\"Contact Form screenshot {781x353}\"></p>\n<h2>Acceptance criteria</h2>\n<p>Before diving into writing the actual tests, it's usually a good idea to reflect on the acceptance criteria to\ndetermine what actually needs to be tested:</p>\n<ul>\n<li>The contact form should be empty by default</li>\n<li>The form can only be submitted if\n<ul>\n<li>All form fields are filled in</li>\n<li>The e-mail address field contains a valid e-mail address</li>\n</ul>\n</li>\n<li>After the form has been successfully submitted\n<ul>\n<li>The fields should be hidden</li>\n<li>A message should be shown saying the form was sent successfully</li>\n</ul>\n</li>\n<li>In case of an http error after submitting the form, an error message should be displayed and the fields should remain\nvisible</li>\n</ul>\n<h2>Support functions</h2>\n<p>Based on these acceptance criteria, we can prepare some support functions to implement the desired checks and to make\nthe actual test file more readable and maintainable. These functions can be added in the Cypress test file on top of\nyour actual tests, or you could add them in specific support file.</p>\n<h3>Retrieving the fields DOM elements</h3>\n<p>Since our contact form already contains ids for each field, the field elements can easily be retrieved:</p>\n<pre><code>type ChainableInputElement = Cypress.Chainable&#x3C;JQuery&#x3C;HTMLInputElement>>;\n\nexport const getNameField = (): ChainableInputElement => cy.get('#field-Name');\nexport const getMailField = (): ChainableInputElement => cy.get('#field-Email');\nexport const getMessageField = (): ChainableInputElement =>\n  cy.get('#field-Message');\nexport const getForm = () => cy.get('form');\n</code></pre>\n<p>The reason we explicitly define the return type for each of the query functions is that by default, <code>cy.get</code> returns a\nChainable <code>HTMLElement</code>, which doesn't allow us to chain with other handy functions\nlike <a href=\"https://docs.cypress.io/api/commands/type\" target=\"_blank\" rel=\"noreferrer\">type</a>.</p>\n<h3>Filling out the form</h3>\n<p>We'll need to be able to fill out the form with some valid dummy values:</p>\n<pre><code>export const completeForm = () => {\n  getNameField().type('John Doe');\n  getMailField().type('john.doe@mail.com');\n  getMessageField().type('This is my message');\n};\n</code></pre>\n<h3>Check validity of fields</h3>\n<p>The fields are all required so they might throw a validation error <code>valueMissing</code>. On top of that, the e-mail\nfield might throw a <code>typeMismatch</code> validation error if the entered value is not a valid e-mail address.</p>\n<pre><code>export const assertValueMissing = (field: ChainableInputElement) =>\n  assertValidity(field, { valueMissing: true });\n\nexport const assertTypeMismatch = (field: ChainableInputElement) =>\n  assertValidity(field, { typeMismatch: true });\n\nconst assertValidity = (\n  field: ChainableInputElement,\n  expectedValidity: { valueMissing?: boolean; typeMismatch?: boolean }\n) =>\n  field.invoke('prop', 'validity').should('deep.include', {\n    valueMissing: false,\n    typeMismatch: false,\n    ...expectedValidity,\n  });\n</code></pre>\n<h3>Form fields visibility</h3>\n<p>The following function verifies if the fields are visible or hidden:</p>\n<pre><code>export const assertFieldsVisible = (visible: boolean) =>\n  cy.get('input').should(visible ? 'have.length.gt' : 'have.length', 0);\n</code></pre>\n<h3>Mocking the api call</h3>\n<p>When we submit the form using a POST request in a Cypress test, we don't want to actually send the form data to the api.\nInstead, we can use <a href=\"https://docs.cypress.io/api/commands/intercept\" target=\"_blank\" rel=\"noreferrer\">intercept</a> to mock the api call and return a\nspecific response.</p>\n<p>Note that we store the intercepted call using an alias so that we can easily check later if the data was submitted or\nnot.</p>\n<pre><code>const submitAlias = 'submit';\n\nexport const mockResponseStatusCode = (statusCode: number) =>\n  cy\n    .intercept('POST', 'http://localhost:4200/api/contact', { statusCode })\n    .as(submitAlias);\n</code></pre>\n<h3>Checking that the form was submitted</h3>\n<p>To verify if the form data was submitted, the previously assigned alias can be used:</p>\n<pre><code>export const assertSubmitted = (submitted: boolean) =>\n  cy.get(`@${submitAlias}`).should(submitted ? 'not.be.null' : 'be.null');\n</code></pre>\n<h3>Submitting the form</h3>\n<p>There is only one button on the page, so we can just click the first button found to submit the form:</p>\n<pre><code>export const clickSubmitButton = () => cy.get('button').click();\n</code></pre>\n<h2>Implementing the Cypress test</h2>\n<p>Now that we have all these support functions ready, we can easily implement the actual tests:</p>\n<pre><code>describe('contact', () => {\n  beforeEach(() => cy.visit('/contact'));\n\n  it('form fields should be empty by default', () =>\n    [getNameField(), getMailField(), getMessageField()].forEach((field) =>\n      field.should('be.empty')\n    ));\n\n  it('form fields should have errors for missing fields', () => {\n    assertValueMissing(getNameField());\n    assertValueMissing(getMailField());\n    assertValueMissing(getMessageField());\n  });\n\n  it('email field should have an error for an incorrect email address', () => {\n    getMailField().type('john.doe@');\n    assertTypeMismatch(getMailField());\n  });\n\n  describe('when submitting an invalid form', () => {\n    beforeEach(() => {\n      mockResponseStatusCode(204);\n      clickSubmitButton();\n    });\n    it('should not send a POST request to the APi', () =>\n      assertSubmitted(false));\n    it('should keep the fields visible', () => assertFieldsVisible(true));\n  });\n\n  describe('when submitting a valid form', () => {\n    beforeEach(() => {\n      completeForm();\n      mockResponseStatusCode(204);\n      clickSubmitButton();\n    });\n    it('should send a POST request to the APi', () => assertSubmitted(true));\n    it('should display a success message', () =>\n      getForm().should('contain', 'Message succesfully sent, thank you!'));\n    it('should hide the form fields', () => assertFieldsVisible(false));\n  });\n\n  describe('when submitting a valid form returns an error response', () => {\n    beforeEach(() => {\n      completeForm();\n      mockResponseStatusCode(400);\n      clickSubmitButton();\n    });\n    it('should send a POST request to the APi', () => assertSubmitted(true));\n    it('should display an error message', () =>\n      getForm().should('contain', 'Something went wrong, try again later.'));\n    it('should keep the fields visible', () => assertFieldsVisible(true));\n  });\n});\n</code></pre>\n<p><img src=\"https://www.pellegrims.dev/assets/blog/e2e-contact-form-cypress/execution.png\" alt=\"Contact Form screenshot {397x419}\"></p>\n<h2>Summary</h2>\n<p>In this article, we demonstrated how to implement automated testing for a simple contact form using <a href=\"https://www.cypress.io/\" target=\"_blank\" rel=\"noreferrer\">Cypress</a>.</p>\n<p>We first defined some acceptance criteria determining the requirements for the contact form. Based on these acceptance criteria, a number of support functions were implemented to keep the final test file more readable and maintainable.\nFinally, these support functions were used in the actual test file.</p>\n",
            "url": "https://www.pellegrims.dev/blog/e2e-contact-form-cypress/",
            "title": "Testing a contact form with Cypress",
            "summary": "How to test a simple contact form using Cypress",
            "image": "https://www.pellegrims.dev/assets/blog/e2e-contact-form-cypress/cover.jpg",
            "date_modified": "2022-08-02T00:00:00.000Z",
            "author": {
                "name": "Robin Pellegrims",
                "url": "https://twitter.com/robinpel"
            }
        },
        {
            "id": "https://www.pellegrims.dev/blog/ng-material-dialog-type-safety/",
            "content_html": "<h2>Introduction</h2>\n<p>Angular Material provides a <code>MatDialogService</code> that allows developers to easily integrate modal dialogs into their\napplications. If you're not familiar with Angular Material or its dialog service, check out\nthe <a href=\"https://material.angular.io/components/dialog\" target=\"_blank\" rel=\"noreferrer\">official documentation</a>.</p>\n<p>While this dialog service is very easy to use, the interaction between the <code>MatDialogService</code> and your dialog component\nisn't completely type-safe and could potentially lead to runtime issues.</p>\n<h2>Use case</h2>\n<p>Our use case is using Angular v17.0.4 and is based\non <a href=\"https://material.angular.io/components/dialog/overview#sharing-data-with-the-dialog-component\" target=\"_blank\" rel=\"noreferrer\">this example</a> in the\nofficial Angular Material documentation.</p>\n<p>The dialog receives an input object representing a favorite animal:</p>\n<pre><code>export interface DialogData {\n  animal: string;\n}\n</code></pre>\n<p>It then displays the animals in a dialog and asks the user to cancel or approve:</p>\n<p><img src=\"https://www.pellegrims.dev/assets/blog/ng-material-dialog-type-safety/dialog.png\" alt=\"Dialog screenshot {252x235}\"></p>\n<p>After clicking one of the buttons, the dialog returns a boolean representing the button that was clicked.</p>\n<h2>Implementation</h2>\n<h3>Parent component</h3>\n<pre><code>&#x3C;!--template-->\n&#x3C;button mat-button (click)=\"openDialog()\">Open dialog&#x3C;/button>\n</code></pre>\n<pre><code>@Component({\n  selector: 'app-component',\n  // template: see above\n})\nexport class AppComponent {\n  private dialog = inject(DialogService);\n\n  protected openDialog() {\n    this.dialog\n      .open(DialogComponent, { data: { animal: 'panda' } })\n      .afterClosed()\n      .pipe(tap((result) => console.log(result === true)))\n      .subscribe();\n  }\n}\n</code></pre>\n<h3>Dialog component</h3>\n<pre><code>&#x3C;!--template-->\n&#x3C;h1 mat-dialog-title>Favorite Animal&#x3C;/h1>\n&#x3C;mat-dialog-content>\n  &#x3C;p>My favorite animal is \"{{ data.animal }}\".&#x3C;/p>\n  &#x3C;p>Do you approve?&#x3C;/p>\n&#x3C;/mat-dialog-content>\n&#x3C;mat-dialog-actions>\n  &#x3C;button mat-button (click)=\"cancelClick()\">Cancel&#x3C;/button>\n  &#x3C;button mat-button (click)=\"okClick()\">Ok&#x3C;/button>\n&#x3C;/mat-dialog-actions>\n</code></pre>\n<pre><code>@Component({\n  selector: 'example-dialog',\n  // template: see above\n})\nexport class DialogComponent {\n  protected data: DialogData = inject(MAT_DIALOG_DATA);\n  protected dialogRef: MatDialogRef&#x3C;DialogComponent> = inject(MatDialogRef);\n\n  protected cancelClick = () => this.dialogRef.close(false);\n  protected okClick = () => this.dialogRef.close(true);\n}\n</code></pre>\n<h2>Type safety issues</h2>\n<p>While the dialog in our use case is currently working perfectly fine, the interaction between the parent and the dialog\ncomponent is not completely type-safe.</p>\n<p>Let's identify some possible issues that will still compile completely fine, but that would break at runtime.</p>\n<h3>Parent component</h3>\n<ul>\n<li>When opening the dialog, a typo could be made in the <code>animal</code> property name that is passed as the dialog data:</li>\n</ul>\n<pre><code>this.dialog.open(DialogComponent, { data: { annimal: 'panda' } });\n</code></pre>\n<ul>\n<li>The parent component receives an untyped result from the <code>afterClosed</code> operator that could be used in a wrong way:</li>\n</ul>\n<pre><code>this.dialog\n  .open(DialogComponent, { data: { animal: 'panda' } })\n  .afterClosed()\n  // this will always log false, since result is a boolean\n  .pipe(tap((result) => console.log(result === 'true')))\n  .subscribe();\n</code></pre>\n<h3>Dialog component</h3>\n<ul>\n<li>In the dialog component we might have forgotten about the correct type we were going to use and use a wrong type\ninstead:</li>\n</ul>\n<pre><code>protected data: { favouriteAnimal: string } = inject(MAT_DIALOG_DATA);\n</code></pre>\n<ul>\n<li>The dialog should return a boolean value after closing, but nothing currently prevents us from passing anything else\nwhen closing the dialog:</li>\n</ul>\n<pre><code>this.dialogRef.close('cancel');\n</code></pre>\n<h3>Parent-child type synchronization</h3>\n<p>There is no synchronization between the Data and Result types used in the parent component and the dialog component.\nThis means the application will still compile when we use different types by mistake on both sides.</p>\n<h2>Adding generic params</h2>\n<p>A first step towards more type-safety would be to explicitly specify the types in the parent component when opening the\ndialog:</p>\n<pre><code>// parent component\nthis.dialog\n  .open&#x3C;DialogComponent, DialogData, boolean>(DialogComponent, {\n    data: { animal: 'panda' },\n  })\n  .afterClosed()\n  // result: boolean | undefined\n  .pipe(tap((result) => console.log(result === true)))\n  .subscribe();\n</code></pre>\n<p>In the dialog component, we can force the result type when injecting the <code>MatDialogRef</code>:</p>\n<pre><code>// dialog component\nprotected data: DialogData = inject(MAT_DIALOG_DATA);\nprotected dialogRef: MatDialogRef&#x3C;DialogComponent, boolean> = inject(MatDialogRef);\n</code></pre>\n<p>While these simple changes effectively force the developer to use correct dialog data and result objects, it still\ndoesn't prevent using different Data/Result types in the parent and dialog component. It also has the drawback that the\ntypes need to be specified in both the parent and child component.</p>\n<h2>Using an abstract dialog component superclass</h2>\n<p>To increase type safety even further between the parent and dialog component and have a single source of truth for the\ndialog Data/Result types, a custom dialog service and abstract dialog component superclass can be created:</p>\n<pre><code>@Directive()\nexport abstract class StronglyTypedDialog&#x3C;DialogData, DialogResult> {\n  protected data: DialogData = inject(MAT_DIALOG_DATA);\n  protected dialogRef: MatDialogRef&#x3C;\n    StronglyTypedDialog&#x3C;DialogData, DialogResult>,\n    DialogResult\n  > = inject(MatDialogRef);\n}\n\n@Injectable({ providedIn: 'root' })\nexport class DialogService {\n  protected dialog = inject(MatDialog);\n\n  open = &#x3C;DialogData, DialogResult>(\n    component: ComponentType&#x3C;StronglyTypedDialog&#x3C;DialogData, DialogResult>>,\n    config?: MatDialogConfig&#x3C;DialogData>\n  ): MatDialogRef&#x3C;\n    StronglyTypedDialog&#x3C;DialogData, DialogResult>,\n    DialogResult\n  > => this.dialog.open(component, config);\n}\n</code></pre>\n<p>Since the constructor has been moved to an abstract superclass, the dialog component can then be simplified like this:</p>\n<pre><code>@Component({\n  selector: 'example-dialog',\n  // template: unchanged, see above\n})\nexport class DialogComponent extends StronglyTypedDialog&#x3C;DialogData, boolean> {\n  protected cancelClick = () => this.dialogRef.close(false);\n  protected okClick = () => this.dialogRef.close(true);\n}\n</code></pre>\n<p>The dialog can then be opened through this new <code>DialogService</code> instead of the regular <code>MatDialog</code> service:</p>\n<pre><code>@Component({\n  selector: 'app-component',\n  // template: unchanged, see above\n})\nexport class AppComponent {\n  private dialog = inject(DialogService);\n\n  protected openDialog() {\n    this.dialog\n      .open(DialogComponent, { data: { animal: 'panda' } })\n      .afterClosed()\n      // result: boolean | undefined\n      .pipe(tap((result) => console.log(result === true)))\n      .subscribe();\n  }\n}\n</code></pre>\n<p>This will achieve full type-safety on both the parent and dialog component while making the DialogComponent the single\nsource of truth for the Data/Result types.</p>\n<h2>Summary</h2>\n<p>We explored multiple possible runtime issues when using Angular Material dialogs:</p>\n<ul>\n<li>passing unexpected data into the dialog</li>\n<li>returning unexpected results from the dialog to the parent component</li>\n<li>using different data/result types in the parent and dialog component</li>\n</ul>\n<p>Some of the issues can be addressed by adding generic params:</p>\n<ul>\n<li>in the function call that opens the dialog</li>\n<li>to the injected <code>MatDialogRef</code> in the dialog constructor</li>\n</ul>\n<p>Finally, the <code>open()</code> method of the <code>MatDialogService</code> can be wrapped in a custom service that provides full type-safety\nand addresses all of the explored issues.</p>\n<h2>More information</h2>\n<ul>\n<li><a href=\"https://github.com/robinpellegrims/angular-material-type-safe-dialog\" target=\"_blank\" rel=\"noreferrer\">Example repository</a></li>\n<li><a href=\"https://material.angular.io/components/dialog\" target=\"_blank\" rel=\"noreferrer\">Official documentation</a></li>\n</ul>\n",
            "url": "https://www.pellegrims.dev/blog/ng-material-dialog-type-safety/",
            "title": "Make Angular Material dialogs type-safe",
            "summary": "How to use Angular Material dialogs in a type-safe way and avoid runtime issues",
            "image": "https://www.pellegrims.dev/assets/blog/ng-material-dialog-type-safety/cover.jpg",
            "date_modified": "2022-06-27T00:00:00.000Z",
            "author": {
                "name": "Robin Pellegrims",
                "url": "https://twitter.com/robinpel"
            }
        },
        {
            "id": "https://www.pellegrims.dev/blog/pipo-m9-tablet-fix-wifi/",
            "content_html": "<p>Ever since I received my <a href=\"http://www.pipo.com/product.php?id=123\" target=\"_blank\" rel=\"noreferrer\">PIPO M9 Pro tablet</a>, I've been experiencing WiFi issues. Every 5-10 minutes, the tablet would simply lose its WiFi connection. Usually it took a few minutes before it would reconnect. No need to say this was very frustrating when doing anything that involves the network connection.</p>\n<p>I've come across various forums (<a href=\"http://www.freaktab.com/showthread.php?8568-Pipo-M9-Pro-wifi-antenna-modification-instructions\" title=\"FreakTab\" target=\"_blank\" rel=\"noreferrer\">FreakTab</a>, <a href=\"http://www.arctablet.com/blog/forum/pipo-max-m9/pipo-m9-pro-wifi-problem/\" target=\"_blank\" rel=\"noreferrer\">ArcTablet</a> and <a href=\"http://tablette-chinoise.net/pipo-m9-pro-problemes-wifi-coupures-ralentissement-t2648/page180.html\" target=\"_blank\" rel=\"noreferrer\">Tablette-Chinoise</a>) full of people complaining about the same issues. The problem seems to be caused by bad placement and bad insulation of the internal WiFi antenna.</p>\n<p>Various solutions were proposed:</p>\n<ul>\n<li>Removing the grounding wire that touches the WiFi antenna and its wire</li>\n<li>Replacing the grounding wire and the WiFi antenna's wire by (better) shielded wires, using wires from old USB cables (involves soldering)</li>\n<li>Isolating the WiFi antenna and its wire by using insulating tape (see <a href=\"http://www.youtube.com/watch?v=d4rEhR01kuY\" target=\"_blank\" rel=\"noreferrer\">instruction video</a>)</li>\n</ul>\n<p>I'm not very experienced with soldering and I didn't really like removing ground wires (they're there for a reason, right?), so I went for the last method.</p>\n<p>I carefully opened my tablet using guitar plectra to put between the screen and the back case. The guy in the video does it with plastic cards, but I couldn't find anything like that. The WiFi antenna turns out to be the black plastic thing glued to the case at the top right. I carefully unglued it by using a screwdriver and I cutted some pieces of cardboard to put underneath the antenna. I then stabilized these pieces of cardboard with some insulation tape, glued the antenna on it and covered the antenna and its wire with a few more layers of insulating tape.</p>\n<p><img src=\"https://www.pellegrims.dev/assets/blog/pipo-m9-tablet-fix-wifi/image1.jpg\" alt=\"Dialog screenshot {1024x768}\">\n<img src=\"https://www.pellegrims.dev/assets/blog/pipo-m9-tablet-fix-wifi/cover.jpg\" alt=\"Dialog screenshot {1024x768}\">\n<img src=\"https://www.pellegrims.dev/assets/blog/pipo-m9-tablet-fix-wifi/image3.jpg\" alt=\"Dialog screenshot {1024x768}\"></p>\n<p>After wrapping it all back together, I rebooted the tablet and the WiFi connection now seems to be much more stable. No more disconnects and usually more than 50Mbps where I had like 10Mbps before. I can't believe these tablets are sold with such a design failure. I guess that's what you get when buying cheap chinese electronics, right? ;-)</p>\n",
            "url": "https://www.pellegrims.dev/blog/pipo-m9-tablet-fix-wifi/",
            "title": "Fixing WiFi on a PIPO M9 Pro tablet",
            "summary": "Easy solution to fix my PIPO M9 Pro tablet's WiFi connection disconnecting every 5-10 seconds",
            "image": "https://www.pellegrims.dev/assets/blog/pipo-m9-tablet-fix-wifi/cover.jpg",
            "date_modified": "2013-12-22T00:00:00.000Z",
            "author": {
                "name": "Robin Pellegrims",
                "url": "https://twitter.com/robinpel"
            }
        },
        {
            "id": "https://www.pellegrims.dev/blog/raspberry-pi-nas-truecrypt-external-hard-drive/",
            "content_html": "<p>Lately I've been playing around with the <a href=\"http://en.wikipedia.org/wiki/Raspberry_Pi\" target=\"_blank\" rel=\"noreferrer\">Raspberry Pi</a> and I decided to use one as a custom <a href=\"http://en.wikipedia.org/wiki/Network-attached_storage\" target=\"_blank\" rel=\"noreferrer\">NAS</a> to serve as a central backup system and as a central hub containing media for my two other Raspberry media centers (running <a href=\"http://openelec.tv/\" target=\"_blank\" rel=\"noreferrer\">OpenElec</a>).</p>\n<p>To provide the actual storage, I bought myself this <a href=\"http://www.seagate.com/external-hard-drives/desktop-hard-drives/expansion-hard-drive/\" target=\"_blank\" rel=\"noreferrer\">Seagate Expansion 3TB</a> hard drive. I chose to install <a href=\"http://www.raspbian.org/\" target=\"_blank\" rel=\"noreferrer\">Raspbian</a> as OS, as it seemed to be the obvious choice in terms of performance.</p>\n<h2>Raspberry Pi as NAS</h2>\n<p>While the Pi's specifications won't allow you to build the most powerful NAS in the world, it still has a lot of advantages.</p>\n<h4>Advantages</h4>\n<ul>\n<li><strong>Energy efficient</strong>: the pi only uses 2W per hour, so all together this means a yearly cost of €5. Of course you need to add to that the energy usage of the external hard drive, which in my case is something like 9W. In total this means a yearly cost of of +/- €20. This is far less than any other NAS system.</li>\n<li><strong>Low noise</strong>: the pi does not make any noise, so you only need to worry about the external hard drive's noise</li>\n<li><strong>Cheap</strong>: pi's are available at around €40, a simple case costs €10 so for +/- €50 you have your NAS system</li>\n<li><strong>Small</strong>: the pi is a pocket-size computer, so it fits anywhere.</li>\n</ul>\n<h4>Disadvantages</h4>\n<ul>\n<li><strong>USB 2.0</strong>: while my external hard drive has a USB 3-0 port, the pi only has 2 USB 2.0 ports. This limits the maximum transfer speed.</li>\n<li><strong>LAN 100Mbps</strong>: if your other network devices have gigabit-speed (or better) lan ports, the transfer speed for reading/writing to your raspberry pi NAS will be limited.</li>\n<li><strong>Performance</strong>: with 512MB of RAM and a default cpu speed of 700MHz you shouldn't expect any miracles, but overall the performance is acceptable if you're not running too many other cpu consuming applications on it</li>\n</ul>\n<h2>Truecrypt</h2>\n<p>I started by formatting and encrypting my external drive on my Ubuntu box. I chose ext4 as filesystem. Then I connected the drive to my Raspberry Pi, using one of the 2 USB ports.</p>\n<p>In the meantime I found <a href=\"http://reinhard-seiler.blogspot.be/2012/07/compile-truecrypt-on-raspberry-pi.html\" target=\"_blank\" rel=\"noreferrer\">this post</a> by <a href=\"http://reinhard-seiler.blogspot.be/\" target=\"_blank\" rel=\"noreferrer\">Reinhard Seiler</a>, telling that Truecrypt doesn't come precompiled for the Raspberry Pi, so I needed to either compile it myself or use the compiled binary available on his blog. So I downloaded the binary from his blog and tried to mount my drive using the compiled Truecrypt binary. Raspbian does not provide some necessary kernel modules for encryption, so you need to use the flag -m=nokernelcrypto to use truecrypt encryption on the Raspberry.</p>\n<p>That was when I ran into the following error message.</p>\n<blockquote>\n<p><em>Error: The drive uses a sector size other than 512 bytes.</em></p>\n<p>Due to limitations of components available on your platform, partition/device-hosted volumes cannot be created/used on the drive.</p>\n<p>Possible solutions:</p>\n<ul>\n<li>Create a file-hosted volume (container) on the drive.</li>\n<li>Use a drive with 512-byte sectors.</li>\n<li>Use TrueCrypt on another platform.</li>\n</ul>\n</blockquote>\n<p>So apparently Truecrypt on Linux doesn't support hard drives with a sector size other than 512 bytes while my brand new external hard drive had a sector size of 4Kb which seems to be the new standard for recent hard drives. The same error appeared when mounting on my Ubuntu box, so it had to be a Truecrypt issue.</p>\n<p>I then stumbled upon <a href=\"http://lenlo.wordpress.com/2013/03/19/truecrypt-mac-os-x-advanced-format-drives-true/\" target=\"_blank\" rel=\"noreferrer\">this post</a> by a guy who ran into the same problem on Mac OSX. He eventually got it working by digging around in the code and compiling his own custom version of Truecrypt. <a href=\"http://karlherrick.com/dev/2013/01/21/compiling-truecrypt-on-raspberry-pi/\" target=\"_blank\" rel=\"noreferrer\">This post</a> by Karl Herrick describes well how to compile Truecrypt on the Raspberry Pi, so I decided to take a look into Truecrypt's source code to eventually correct the issue and compile my own Truecrypt binary as well.</p>\n<p>I downloaded the source code for Truecrypt 7.1a and I eventually found the following section in the file Core/Unix/CoreUnix.cpp on line 445:</p>\n<pre><code>#if defined (TC_LINUX)\n  if (volume - > GetSectorSize() != TC_SECTOR_SIZE_LEGACY) {\n      if (options.Protection == VolumeProtection::HiddenVolumeReadOnly)\n          throw UnsupportedSectorSizeHiddenVolumeProtection();\n      if (options.NoKernelCrypto)\n          throw UnsupportedSectorSizeNoKernelCrypto();\n  }\n#endif\n</code></pre>\n<p>So it seems that when we're using the nokernelcrypto flag for mounting truecrypt-encrypted hard drives with sector sizes other than 512bytes, Truecrypt fails by design.</p>\n<p>While not having any clue whatsoever as to why this was implemented this way, I commented out these 2 lines as follows:</p>\n<pre><code>#if defined(TC_LINUX)\nif (volume - &#x26; gt; GetSectorSize() != TC_SECTOR_SIZE_LEGACY) {\n    if (options.Protection == VolumeProtection::HiddenVolumeReadOnly)\n        throw UnsupportedSectorSizeHiddenVolumeProtection();\n\n    //if (options.NoKernelCrypto)\n    //throw UnsupportedSectorSizeNoKernelCrypto();\n}\n#endif\n</code></pre>\n<p>Then I followed the instructions on <a href=\"http://karlherrick.com/dev/2013/01/21/compiling-truecrypt-on-raspberry-pi/\" target=\"_blank\" rel=\"noreferrer\">Karl Herrick's blog post</a> to compile Truecrypt, but there were some errors in his script, so I adapted it as follows:</p>\n<pre><code>#get source files other than the TrueCrypt source\nsudo wget -P /usr/local/src http://prdownloads.sourceforge.net/wxwindows/wxWidgets-2.8.11.tar.gz\nsudo wget -P /usr/local/src/pkcs11 ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v211/pkcs11.h\nsudo wget -P /usr/local/src/pkcs11 ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v211/pkcs11f.h\nsudo wget -P /usr/local/src/pkcs11 ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-11/v211/pkcs11t.h\n\n#get and install dependent packages\nsudo apt-get -y install libgtk2.0-dev libfuse-dev nasm libwxgtk2.8-dev\n\n#extract, configure, and make wxWidgets\nsudo tar -xzvf /usr/local/src/wxWidgets-2.8.11.tar.gz -C /usr/local/src\ncd /usr/local/src/wxWidgets-2.8.11/\n./configure\nmake\n\n#setup, extract\nexport PKCS11_INC=/usr/local/src/pkcs11\nsudo tar -xzvf /usr/local/src/TrueCrypt\\\\ 7.1a\\\\ Source.tar.gz -C /usr/local/src\ncd /usr/local/src/truecrypt-7.1a-source\n\n#comment out some lines that prevented building\nsed -i 's#TC_TOKEN_ERR (CKR_NEW_PIN_MODE)#/\\*TC_TOKEN_ERR (CKR_NEW_PIN_MODE)\\*/#g' Common/SecurityToken.cpp\nsed -i 's#TC_TOKEN_ERR (CKR_NEXT_OTP)#/\\*TC_TOKEN_ERR (CKR_NEXT_OTP)\\*/#g' Common/SecurityToken.cpp\nsed -i 's#TC_TOKEN_ERR (CKR_FUNCTION_REJECTED)#/\\*TC_TOKEN_ERR (CKR_FUNCTION_REJECTED)\\*/#g' Common/SecurityToken.cpp\n\n#compile, build, make!\nsudo make WX_ROOT=/usr/local/src/wxWidgets-2.8.11/ wxbuild\nsudo -E make WXSTATIC=1\n\necho\necho TrueCrypt should be found in /usr/local/src/truecrypt-7.1a-source/Main/\n</code></pre>\n<p>By using this custom version of Truecrypt, I finally got to mount my drive without any issues and it's still working like a charm after a few months. The drive is operating the way it should and I have not lost any data so far.</p>\n",
            "url": "https://www.pellegrims.dev/blog/raspberry-pi-nas-truecrypt-external-hard-drive/",
            "title": "Raspberry Pi NAS with Truecrypt and a 4 KB sector size external hard drive",
            "summary": "Turning a Raspberry Pi into a NAS with encrypted external storage",
            "image": "https://www.pellegrims.dev/assets/blog/raspberry-pi-nas-truecrypt-external-hard-drive/cover.jpg",
            "date_modified": "2013-10-29T00:00:00.000Z",
            "author": {
                "name": "Robin Pellegrims",
                "url": "https://twitter.com/robinpel"
            }
        }
    ]
}